# Some R Notes

This R document contains some notes I've made while working through material from Hadley Wickham's excellent book [Advanced R](http://adv-r.had.co.nz/). 
The notes are written in R Markdown using the [knitr](http://yihui.name/knitr) package. 

----

## R Functions I'm ashamed I didn't know...

----

### `str`  -- *"Compactly display the structure of an arbitrary R object"*
It does what it says: give it any R object as an argument and `str` will tell you what's inside. 
Let's look at some simple examples.
#### `str` Examples: Atomic Vectors
```{r}
x <- 1:3
x
str(x)
y <- c(1.0, 2.0, 3.0)
y
str(y)
z <- rnorm(3)
z
str(z)
people <- c("Alice", "Bob", "Charlie")
people
str(people)
```
#### `str` Examples: Matrices
```{r}
M <- matrix(1:4, 2, 2)
M
str(M)
N <- matrix(rnorm(4), 2, 2)
str(N)
P <- matrix(paste("Person", 1:4, sep = ""), 2, 2)
P
str(P)
```
#### `str` Examples: Dataframes
```{r}
str(cars)
str(iris)
```

#### `str` Examples: Arbitrary Lists
```{r}
M <- matrix(rnorm(4), 2, 2)
friends <- c("Alice", "Bob", "Charlie")
mylist <- list(M, friends)
mylist
str(mylist)
```
#### `str` Examples: Functions
```{r}
str(mean)
add2 <- function(x, y){ x + y }
str(add2)
```
----

### `drop`  -- *"Drop redundant extent information"*

This is both a standalone function and an option that can be used with the various subsetting commands such as `[` and `subset`. 

#### `drop` Examples: Standalone Function
The matrix `M` has only one column, so we could have stored the same information as a vector if we had wanted to. 
The `drop` function makes this simplification. 
In other words it deletes "the dimensions of an array which have only one level"
```{r}
M <- matrix(1:5, 5, 1)
M
drop(M)
```

#### `drop` Examples: Argument to Subsetting Functions
Both `[` and `subset` take `drop` as a logical argument.
While `[` defaults to `drop = TRUE`
```{r}
M <- matrix(1:4, 2, 2)
M[1,]
M[1, ,drop = FALSE]
```
`subset` defaults to `drop = FALSE`
```{r}
data <- data.frame(age = c(20, 35, 16))
subset(data, age != 35)
subset(data, age != 35, drop = TRUE)
```
Setting `drop = FALSE` with `[` can be crucial for getting the results you expect in matrix operations. 
The following code, for example, does not do what we'd expect: it gives the *inner* product rather than the *outer* product:
```{r}
M <- matrix(1:4, 2, 2)
x <- M[,1]
y <- M[2,]
x %*% y
```
Incidentally, this presents another opportunity to demonstrate `drop` as a standalone function:
```{r}
drop(x %*% y)
```
To get the *outer* product, we use `drop` as an argument to `[` as follows
```{r}
x <- M[,1,drop = FALSE]
y <-  M[2,,drop = FALSE] 
x %*% y 
```

### `match`  -- *"Value matching"*
This function has a binary operator counterpart `%in%`. 
Whereas `match` returns a vector of *positions*, possibly including `NA`s, `%in%` returns a logical vector *without* `NA`s. 
Both `match` and `%in%` try to match the elements of their *first* argument with elements of their *second* argument.
This means that each returns a result of the same dimension of the *first* argument.

#### `match` Examples: Atomic Vectors
```{r}
friends <- c("Alice", "Bob", "Charlie")
coworkers <- c("Bob", "Charlie", "Diana", "Elise")
match(friends, coworkers)
friends %in% coworkers
```
Because Alice is not an element of `coworkers`, `match` cannot return a position, so it returns `NA` instead.
Now try reversing the order of the arguments:
```{r}
match(coworkers, friends)
coworkers %in% friends
```
What about multiple matches?
```{r}
x <- 1:5
y <- c(2, 3, 4, 4)
```
The function `match` handles multiple matches by returning the position of the *first* match
```{r}
match(x, y)
```
In contrast, `%in%` simply returns TRUE, indicating that there is at least one match
```{r}
x %in% y
```
Both `match` and `%in%` take *vector* arguments. So what happens, for example, if we try to pass them a matrix?
```{r}
m <- c(11, 13, 19)
M <- matrix(11:19, 3, 3)
m
M
```
To understand the following, remember that we *can* access R matrices with a single index, where the convention is to treat the whole matrix as a vector in which the *columns* are pasted together 
```{r}
M[1]
M[1:4]
```
Thus,
```{r}
match(m, M)
m %in% M
match(M, m)
M %in% m
M %in% M
```

